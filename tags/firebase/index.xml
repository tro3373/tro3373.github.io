<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>firebase on tac lifelog</title>
    <link>https://tro3373.github.io/tags/firebase/</link>
    <description>Recent content in firebase on tac lifelog</description>
    <image>
      <title>tac lifelog</title>
      <url>https://tro3373.github.io/favicon.png</url>
      <link>https://tro3373.github.io/favicon.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 18 Nov 2025 13:50:49 +0900</lastBuildDate><atom:link href="https://tro3373.github.io/tags/firebase/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FirestoreのorderByには暗黙のフィルタがある</title>
      <link>https://tro3373.github.io/posts/2025/2025-11-18-cloud-firestore-order-and-limit-data/</link>
      <pubDate>Tue, 18 Nov 2025 13:50:49 +0900</pubDate>
      
      <guid>https://tro3373.github.io/posts/2025/2025-11-18-cloud-firestore-order-and-limit-data/</guid>
      <description>結論：orderByは指定フィールドの存在でもフィルタリングする FirestoreのorderBy()句は、指定したフィールドが存在しないドキュメントを自動的に除外する。
並べ替えだけでなく、暗黙的にフィルタリングも行うため、予期しないデータ欠落が発生する可能性がある。
問題：orderByで結果が減る // 「createdAt」フィールドでソート query := client.Collection(&amp;#34;users&amp;#34;).OrderBy(&amp;#34;createdAt&amp;#34;, firestore.Asc) このクエリでは、createdAtフィールドが存在しないドキュメントは結果に含まれない。
例：
✅ {id: 1, name: &amp;quot;Alice&amp;quot;, createdAt: &amp;quot;2025-01-01&amp;quot;} → 結果に含まれる ❌ {id: 2, name: &amp;quot;Bob&amp;quot;} → 結果から除外される（createdAtがない） 公式ドキュメントの記載 orderBy() 句は、指定したフィールドの有無によるフィルタも行います。指定したフィールドがないドキュメントは結果セットには含まれません。
Cloud Firestore でデータを並べ替えたり制限する | Firebase 範囲比較との組み合わせ制約 範囲比較（&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=）のフィルタがある場合、最初のorderBy()は同じフィールドで行う必要がある。
// ❌ NG: 範囲比較（age）と異なるフィールド（name）で最初にorderBy query := client.Collection(&amp;#34;users&amp;#34;). Where(&amp;#34;age&amp;#34;, &amp;#34;&amp;gt;&amp;#34;, 20). OrderBy(&amp;#34;name&amp;#34;, firestore.Asc) // エラー: 最初のorderByはageにする必要がある // ✅ OK: 範囲比較と同じフィールド（age）で最初にorderBy query := client.Collection(&amp;#34;users&amp;#34;). Where(&amp;#34;age&amp;#34;, &amp;#34;&amp;gt;&amp;#34;, 20). OrderBy(&amp;#34;age&amp;#34;, firestore.Asc). OrderBy(&amp;#34;name&amp;#34;, firestore.Asc) 対策：フィールド存在を意識する 1.</description>
    </item>
    
    <item>
      <title>node.js firebase-admin の multicast 時のレスポンスの配列と、指定したトークンの配列順序は一致する</title>
      <link>https://tro3373.github.io/posts/2023/2023-03-01-firebase-admin-multicast-response-is-same-order-with-specified-tokens/</link>
      <pubDate>Wed, 01 Mar 2023 21:25:03 +0900</pubDate>
      
      <guid>https://tro3373.github.io/posts/2023/2023-03-01-firebase-admin-multicast-response-is-same-order-with-specified-tokens/</guid>
      <description>Firebase Cloud Messagingで firebase-admin - npm 使って Multicastすると、複数のデバイスに対して一度にプッシュ通知を送信することができるけど、 どのTokenが失敗したのかわからないのでは？と思い調べた
So to confirm, the response array from sendMulticast is in the same order as the tokens that were passed in, allowing you to match up the indexes of any errors.
https://stackoverflow.com/questions/70008515/firebase-cloud-messaging-multicast-error-messaging-registration-token-not-regist ここにある通り、 multicast 時のトークン配列と、 応答される BatchResponse の配列順序は一致する らしいので、どのトークンが失敗したのかはわかるみたい</description>
    </item>
    
    <item>
      <title>firebase-admin で使用する秘密鍵を SecretManager に登録する</title>
      <link>https://tro3373.github.io/posts/2023/2023-02-13-register_secret_key_for_firebase_admin_to_secret_manager/</link>
      <pubDate>Mon, 13 Feb 2023 10:13:37 +0900</pubDate>
      
      <guid>https://tro3373.github.io/posts/2023/2023-02-13-register_secret_key_for_firebase_admin_to_secret_manager/</guid>
      <description>FCM Push用秘密鍵を SecretManager に登録する FCM 秘密鍵を取得 FireBaseへログイン プロジェクトを選択 プロジェクトの設定 サービスアカウント FireBase Admin SDK &amp;gt; 新しい秘密鍵の生成 FCM 秘密鍵を SecretManager に登録 取得した秘密鍵を ./fcm.json で配置する 以下コマンドで登録 aws secretsmanager put-secret-value --secret-id ${SECRET_ID} --secret-string &amp;#34;$(cat&amp;lt;./fcm.json)&amp;#34; 使う SecretManager を扱い易いようにクラス化する &amp;#39;use strict&amp;#39;; const { SecretsManagerClient, GetSecretValueCommand } = require(&amp;#39;@aws-sdk/client-secrets-manager&amp;#39;); const clazz = class Sm { constructor() { this.client = new SecretsManagerClient({ region: process.env.REGION }); // REGION で環境変数へRegionを設定している前提 } async get(key) { const command = new GetSecretValueCommand({ SecretId: key }); const res = await this.</description>
    </item>
    
  </channel>
</rss>
